import datetime
from  dateutil import relativedelta

from django.conf import settings
from django.core.exceptions import ImproperlyConfigured

from django.core.exceptions import ObjectDoesNotExist
from django.core.cache import cache

from profiles.models import Profile
from profiles.constants import OZ
_inbox_count_sources = None

def inbox_count_sources():
    global _inbox_count_sources
    if _inbox_count_sources is None:
        sources = []
        for path in settings.COMBINED_INBOX_COUNT_SOURCES:
            i = path.rfind('.')
            module, attr = path[:i], path[i+1:]
            try:
                mod = __import__(module, {}, {}, [attr])
            except ImportError, e:
                raise ImproperlyConfigured('Error importing request processor module %s: "%s"' % (module, e))
            try:
                func = getattr(mod, attr)
            except AttributeError:
                raise ImproperlyConfigured('Module "%s" does not define a "%s" callable request processor' % (module, attr))
            sources.append(func)
        _inbox_count_sources = tuple(sources)
    return _inbox_count_sources

def combined_inbox_count(request):
    """
    A context processor that uses other context processors defined in
    setting.COMBINED_INBOX_COUNT_SOURCES to return the combined number from
    arbitrary counter sources.
    """
    count = 0
    for func in inbox_count_sources():
        counts = func(request)
        if counts:
            for value in counts.itervalues():
                try:
                    count = count + int(value)
                except (TypeError, ValueError):
                    pass
    return {'combined_inbox_count': count,}

def footer(request):

    query = """
        SELECT "profiles_profile"."id", "profiles_profile"."user_id", "profiles_profile"."name", 
        COUNT("kills_kill"."id") AS "kills" FROM "profiles_profile" 
             LEFT OUTER JOIN "profiles_player" ON ("profiles_profile"."id" = "profiles_player"."profile_id") 
             LEFT OUTER JOIN "kills_kill" ON ("profiles_player"."id" = "kills_kill"."killer_id") 
             where "profiles_player"."state" <> %s or "profiles_player"."revealed" = True
                  GROUP BY "profiles_profile"."id", "profiles_profile"."user_id", "profiles_profile"."name" 
        ORDER BY "kills" DESC LIMIT 5;
        """

    top_five_zombs = Profile.objects.raw(query, [OZ])
    return {
        "top_five_zombs": top_five_zombs,
    }


def user_info(request):
    """If the user is logged in, populate with user data (is plus, is mod, etc)
    XXX: Cache the fuck outta this, oh holy fucking crap yes.
         Make a cache key unique to this user (eg 'stats' + user.pk)
         so we can easily identify and invalidate it when calls that change statistics are used
    """
    
    if request.is_ajax():
        return {}
    user = getattr(request, 'user', False)

    if user and user.is_authenticated():
        # micro-optimization here, rather than looking up the profile
        # data each time we need it, get it once and store it in the
        # context.

        # hey bixly django automatically caches that in the user object.
        # morons.
        
        try:
            profile = user.get_profile()
            try:
                player = profile.get_active_player()
            except ObjectDoesNotExist:
                player = None
        except ObjectDoesNotExist:
            profile = None

        if user.is_staff:
            can_moderate = True
        elif player:
            can_moderate = player.is_mod
        else:
            can_moderate = False

        ctx = {'is_mod': can_moderate, 'logged_in':True}
        if profile:
            ctx.update(is_plus = profile.is_plus, profile = profile)

        if profile and player:
            game   = player.game
            alive_this_game = relativedelta.relativedelta(datetime.datetime.now(), game.start)
            hours_this_game = alive_this_game.days * 26 + alive_this_game.hours
            kills_this_game = player.kills.count()
            mods = game.players.filter(is_mod=True)


            ctx['stats'] = True
            ctx['game_start_time'] = game.start
            ctx['alive_this_game'] = alive_this_game
            ctx['hours_this_game'] = hours_this_game
            ctx['kills_this_game'] = kills_this_game
            ctx['mods'] = mods
            

            ctx.update(profile.career_stats())
            return ctx
    return {}

