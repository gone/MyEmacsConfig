#Copyright 2010 by Gerrity Labs. All Rights Reserved.

from django.contrib.auth.models import User
from django.db import models

from slader.common.models import AbstractBase


class TransactionType(AbstractBase):
    """records the kind of transaction it is."""
    type = models.CharField(max_length=255)
    description = models.CharField(max_length=255)
    
    def __unicode__(self):
        return 'TransactionType: %s' % self.type

    
class Transfer(AbstractBase):
    """
    Stores any single transfer of credit.

    A user, amount and date of the transaction are stored, as well as the type of transfer.
    
    """

    user = models.ForeignKey(User)
    time_stamp = models.DateTimeField(auto_now_add=True)
    amount = models.IntegerField()
    
    type = models.ForeignKey(TransactionType, null=False)
    credit = models.BooleanField() # Since payments must be either a credit or a debit...
    description = models.CharField(max_length=255, blank=True)
    midwife = models.ForeignKey('midwife.Midwife', related_name='transfers', null=True)
    
    class Meta:
        app_label = 'payment'
        ordering = ('-time_stamp',)

    def __unicode__(self):
        return 'Transfer: %s (%s)' %(self.amount, self.time_stamp)


    def delete(self, *args, **kwargs):
        self.clear_nullable_related()
        super(Transfer, self).delete(*args, **kwargs)

    def clear_nullable_related(self):
        """
        Recursively clears any nullable foreign key fields on related objects.
        Django is hard-wired for cascading deletes, which is very dangerous for
        us. This simulates ON DELETE SET NULL behavior manually.
        """
        for related in self._meta.get_all_related_objects():
            accessor = related.get_accessor_name()
            related_set = getattr(self, accessor)

            if related.field.null:
                related_set.clear()
            else:
                for related_object in related_set.all():
                    related_object.clear_nullable_related()


class SolutionView(AbstractBase):
    """
    A SolutionView stores the date that a user accesses a specific solution.
    Each SolutionView is logged and involves a specific cost to the user, as applied
    through the related SolutionViewTransaction models.

    Each SolutionView may have multiple credits, and a single debit.

    """
    
    solution = models.ForeignKey('solutions.Solution', related_name='views')
    time_stamp = models.DateTimeField(auto_now_add=True)
    user = models.ForeignKey(User, related_name='solutionviews')
    ip_used = models.CharField(blank=True, help_text="If accessible", max_length=100)
    duplicate = models.BooleanField(default=False, help_text="Records whether this is simply a duplicate view, in which case there is no credit/debit associated.")

    transfers = models.ManyToManyField('payment.Transfer', related_name='views')
    
    class Meta:
        app_label = 'payment'

    def __unicode__(self):
        return 'Solution View: %s (%s)' %(self.solution, self.time_stamp)


class AnonymousUserView(models.Model):
    """
    A way of tracking views by anonymous users
    """
    
    solution = models.ForeignKey('solutions.Solution', null=True, blank=True)
    time_stamp = models.DateTimeField(auto_now_add=True)
    ip = models.IPAddressField(default='0.0.0.0')

    textbook_page = models.ForeignKey('solutions.TextbookPage', null=True, blank=True)
    
    class Meta:
        app_label = 'payment'
        unique_together = ( ('ip', 'solution'), ('ip', 'textbook_page') )
    

class AnonymousSession(AbstractBase):
    """
    Capture an IP and other info about an anonymous session to be able to take a look at this behavior
    """

    time_stamp = models.DateTimeField()
    ip = models.IPAddressField(default='0.0.0.0')
    points_granted = models.IntegerField(default=0)
    browser = models.CharField(max_length=255, default='unknown')
    referer = models.CharField(max_length=2048, default='unknown')

    class Meta:
        app_label = 'payment'


class PayoutRequest(AbstractBase):
    """
    A request for payout of points into cash
    """

    user = models.ForeignKey(User, related_name="payout_requests")
    cash_value = models.DecimalField(decimal_places=2, max_digits=6)
    paypal_email = models.EmailField()
    transfer = models.ForeignKey('payment.Transfer')
    approved = models.BooleanField(default=False)
    approved_by = models.ForeignKey(User, null=True, related_name="payout_approvals")
    paid = models.BooleanField(default=False)

    check_requested = models.BooleanField(default=False)
    

    class Meta:
        app_label = 'payment'

    @property
    def status(self):
        if self.paid:
            return 'paid'
        else:
            if not self.approved:
                return 'pending'
            else:
                return 'approved'

    @property
    def cumulative_payouts_to_user(self):
        user = self.user
        user_payouts = PayoutRequest.objects.filter(user=user)
        cumulative = sum(p.cash_value for p in user_payouts)
        return cumulative

