#Copyright 2010 by Gerrity Labs. All Rights Reserved.

import datetime
import StringIO
from xml.dom.minidom import parseString

from django.shortcuts import get_object_or_404
from django.utils.encoding import smart_unicode
from django.utils.xmlutils import SimplerXMLGenerator

from piston.handler import BaseHandler
from piston.resource import Resource
from piston.emitters import XMLEmitter
from piston.utils import rc

from slader.solutions.models import Textbook, TextbookPage, Exercise, Solution, TextbookExerciseGroup
from slader.common.decorators import simple_decorator
from slader.common.util import ankey


mapped_isbns = {
                '0618851526xx9': '9780618851522',
                '0618851526xx2': '9780618851522',
                '0618851526x11': '9780618851522',
                                                
                '1439048479xx2': '9781439048474',
                '1439048479xx1': '9781439048474',
                                                
                '9780547315xx8': '9780547315171',
                '9780547315x11': '9780547315171',
                '9780547315x12': '9780547315171',
                '9780547315x10': '9780547315171',
                '9780547315xx9': '9780547315171',
                '9780547315xx5': '9780547315171',

                '9780547315xx6': '9780547315263',
                '9780547315xx7': '9780547315263',
                '97805473152x8': '9780547315263',
                '97805473152x9': '9780547315263',
                '978054731xx10': '9780547315263',

                '978xx31924963': '9780131924963',

                '9780030995xx2': '9780030995743',

                '9780131362xx2': '9780131362215',

                '97800787773x0': '9780078777370',
                '97800787773x1': '9780078777370',

                '032152884xx1': '9780321528841',
                '032152884xx2': '9780321528841',

                '1439044600xx1': '9780534402129',

                '97806188876x8': '9780618887699',
                
                '9781603280xx2': '9781603280433',

                '1439044600xx2': '9780534402129',

                '0133706206xx2': '9780133706208',

                '9xx0133706185': '9780133706185',
                }


# reservations for books that will be disappearing from the database
legacy_reservations = {
 3: ['978054731xx10',
     '1439048479xx2',
     '2222222222222',
     '3333333333333'],
 4: ['97800787773x1', '9780547315171'],
 13: ['9780547315x11', '9780618958252'],
 19: ['9780078681769', '97806188876x8'],
 38: ['032152884xx2'],
 39: ['1439048479xx2'],
 40: ['9780547315x12', '9781603280xx2'],
 41: ['032152884xx1'],
 47: ['0618851526xx9', '1439048479xx1'],
 61: ['2222222222222', '97800787773x0'],
 89: ['1439044600xx2'],
 95: ['9780132014083', '97805473152x9'],
 96: ['9780547315263', '0618851526xx2'],
 110: ['9780131924963', '9780547315xx9'],
 111: ['0133706206xx2'],
 126: ['9780716707806', '9780547315x10'],
 128: ['1439044600xx1'],
 142: ['9781439049501', '0618851526x11'],
 162: ['9780131362xx2'],
 167: ['9780547315xx6'],
 168: ['9780547315xx7'],
 169: ['97805473152x8'],
 170: ['9780547315xx5', '9780547315xx8'],
 172: ['0618851526xx2'],
 174: ['9780547315xx5'],
 175: ['978054731xx10'],
 177: ['1439048479xx1'],
 184: ['9780030995xx2'],
}


def map_isbn(isbn):
    try:
        isbn = mapped_isbns[isbn]
    except KeyError:
        isbn = isbn
    return isbn


@simple_decorator
def mapped_isbn(fn):
    def mapped_isbn_fn(*args, **kwargs):
        try:
            isbn = kwargs['isbn']
            new_isbn = map_isbn(isbn)
            kwargs['isbn'] = new_isbn
        except KeyError:
            isbn = args['isbn']
            new_isbn = map_isbn(isbn)
            args['isbn'] = new_isbn
        return fn(*args, **kwargs)
    return mapped_isbn_fn


class XMLResource(Resource):
    def determine_emitter(self, request, *args, **kwargs):
        """since we're always going to be emitting xml, subclass the default resource
        to create a different emitter"""
        em = kwargs.pop('emitter_format', None)
        if not em:
            em = request.GET.get('format', 'xml')
        return em



class XMLAttributeEmmiter(XMLEmitter):
    def create_attrs(self, item):
        attrs = {}
        if 'id' in item:
            attrs['id'] = str(item.pop('id'))
        if 'modified_on' in item:
            attrs['modified_on'] = item.pop('modified_on').strftime("%Y-%m-%d %H:%M:%S")
        return attrs
    
    def _to_xml(self, xml, data):
        if isinstance(data, (tuple, list)):
            for item in data:
                attrs = {}
                if isinstance(item, dict):
                    attrs = self.create_attrs(item)
                xml.startElement("resource", attrs)
                self._to_xml(xml, item)
                xml.endElement("resource")
        elif isinstance(data, dict):
            for k, v in data.iteritems():
                attrs = {}
                if isinstance(v, dict):
                    attrs = self.create_attrs(v)
                xml.startElement(k, attrs)
                self._to_xml(xml, v)
                xml.endElement(k)
        else:
            xml.characters(smart_unicode(data))


    def render(self, request):
        stream = StringIO.StringIO()
        
        xml = SimplerXMLGenerator(stream, "utf-8")
        xml.startDocument()
        xml.startElement("response", {})
        construct =  self.construct()
        if isinstance(construct, dict):
            construct = [construct]
        self._to_xml(xml, construct)
        
        xml.endElement("response")
        xml.endDocument()
        return stream.getvalue()


class TextbookHandler(BaseHandler):
    model = Textbook
    fields = ('isbn', 'title', 'year_published', 'num_pages', 'modified_on')

    def read(self, request, isbn=None):
        if isbn:
            # find the mapped isbn
            m_isbn = map_isbn(isbn)
            
            # get the real textbook object
            textbook = get_object_or_404(Textbook, isbn=m_isbn)

            # show with the non-mapped isbn
            textbook.isbn = isbn
            textbooks = [textbook]
        else:
            # find the user's legacy reservations
            try:
                lres = legacy_reservations[request.user.id]
                textbooks = []
                for isbn in lres:
                    # find the mapped isbn
                    m_isbn = map_isbn(isbn)

                    # get the real textbook object
                    textbook = get_object_or_404(Textbook, isbn=m_isbn)

                    # calc modified on dates
                    pages = TextbookPage.active_objects.filter(textbook=textbook)
                    if any(lambda p: p.modified_on > textbook.modified_on for p in pages):
                        textbook.modified_on = max([p.modified_on for p in pages])

                    # show with the non-mapped isbn
                    textbook.isbn = isbn
                    textbooks.append(textbook)
                
            except KeyError: #no legacy reservations
                textbooks = Textbook.active_objects.filter(reservation__user=request.user)

                for text in textbooks:
                    # a hack to update textbook modified_on based on pages contained within
                    pages = TextbookPage.active_objects.filter(textbook=text)
                    if any(lambda p: p.modified_on > text.modified_on for p in pages):
                        text.modified_on = max([p.modified_on for p in pages])

        return textbooks

    
class TextbookPageHandler(BaseHandler):
    model = TextbookPage
    fields = ('slug', 'modified_on', 'finished')

    @mapped_isbn
    def read(self, request, isbn, slug=None):
        text = get_object_or_404(Textbook, isbn=isbn)
        if slug:
            pages = [get_object_or_404(TextbookPage, slug=slug, textbook=text)]
        else:
            pages =  TextbookPage.active_objects.filter(textbook=text)
        for page in pages:
            
            # a hack to update page modified_on based on exercises contained within
            exercises = Exercise.active_objects.filter(pages=page)
            if any(lambda e: e.modified_on > page.modified_on for e in exercises):
                page.modified_on = max([e.modified_on for e in exercises])

            exercises = page.exercises.all()
            solutions = Solution.active_objects.filter(exercise__in=exercises, user=request.user)
            finisheds = [s.finished for s in solutions]
            if finisheds:
                if all(finisheds) and len(finisheds) == len(exercises):
                    page.finished = "Finished"
                elif any(finisheds):
                    page.finished = "Incomplete"
                else:
                    page.finished = "Not started"
            else:
                page.finished = "Not started"
        return sorted(pages, key=lambda p:ankey(p.slug))


class ExerciseHandler(BaseHandler):
    model = Exercise
    fields = ('name', 'exercise_group', 'id', 'slug',  'modified_on', 'finished')

    status_codes = {'not_yet_started':'Not started',
                    'complete':'Finished',
                    'incomplete':'Incomplete'}
        
    def jit_single_solution(self, exercise, user):
        try:
            solution = Solution.active_objects.get(exercise=exercise, user=user)
        except Solution.DoesNotExist:
            solution = Solution(exercise=exercise, user=user)
            solution.save()
        except Solution.MultipleObjectsReturned:
            pass

    def jit_many_solutions(self, exercises, user):
        solutions = Solution.active_objects.filter(exercise__in=exercises)
        for exercise in exercises:
            if not solutions.filter(exercise=exercise, user=user):
                solution = Solution(exercise=exercise, user=user)
                solution.save()

    def make_group_display_name(self, exercises, isbn):
        for exercise in exercises:
            exercise.exercise_group.name = exercise.groups.get(textbook__isbn=isbn).display_name

    def define_group(self, exercises, isbn):
        for exercise in exercises:
            exercise.exercise_group = exercise.groups.get(textbook__isbn=isbn)

    def define_name_slug(self, exercises):
        for exercise in exercises:
            ex_in_group = exercise.exerciseingroup_set.get(group=exercise.exercise_group)
            exercise.name = ex_in_group.name
            exercise.slug = ex_in_group.slug

    def is_complete(self, exercises):
        for e in exercises:
            e.finished = self.status_codes[e.status]

    @mapped_isbn
    def read(self, request, isbn, slug, exercise_id=None):
        if exercise_id:
            exercise = get_object_or_404(Exercise, id=exercise_id)
            self.jit_single_solution(exercise, request.user)
            self.is_complete([exercise])
            self.define_group([exercise], isbn)
            self.define_name_slug([exercise])
            self.make_group_display_name([exercise], isbn)
            return exercise
        else:
            textbook = get_object_or_404(Textbook, isbn=isbn)
            textbook_page = get_object_or_404(TextbookPage, slug=slug, textbook=textbook)
            exercises = Exercise.active_objects.filter(pages=textbook_page)
            self.define_group(exercises, isbn)
            self.define_name_slug(exercises)
            self.make_group_display_name(exercises, isbn)
            self.jit_many_solutions(exercises, request.user)
            self.is_complete(exercises)
            return sorted(exercises, key=lambda e:ankey(e.name))


class TextbookExerciseGroupHandler(BaseHandler):
    model = TextbookExerciseGroup
    fields = ('name', 'id', )
        

class SolutionHandler(BaseHandler):
    model = Solution
    fields = ('result', 'explanation', 'exercise',  'modified_on', 'finished')
    
    @mapped_isbn
    def read(self, request, isbn, slug, exercise_id):
        """ This one is a little different - since right now, we only have one solution per exercise
        we can just dump the set of solutions attatched to given exercise id."""
        solutions = list(Solution.active_objects.filter(exercise__id=exercise_id, user=request.user))
        for solution in solutions:
            solution.result = ' '
            solution.explanation = ' '
        return solutions

    def update(self, request, isbn, slug, exercise_id):
        def not_here(msg):
            resp = rc.NOT_HERE
            resp.write(" " + msg)
            return resp
        def get_xml_data(tagName, nodeName, default):
            elements = sd.getElementsByTagName(tagName)
            if elements.length == 0:
                return default
            for item in elements:
                if item.nodeName == nodeName:
                    return item.firstChild.nodeValue
            else: 
                return default

        #make sure the request is pointing at real things
        try:
            textbook = Textbook.active_objects.get(isbn=isbn)
            TextbookPage.objects.get(slug=slug, textbook=textbook)
            Exercise.objects.get(id=exercise_id)
        except Textbook.DoesNotExist:
            return not_here("The textbook identified by isbn %s isn't in our records!" %isbn)
        except TextbookPage.DoesNotExist:
            return not_here("The page on textbook %s identified by %s isn't in our records!" % (isbn, slug))
        except Exercise.DoesNotExist:
            return not_here("The exercise identified by %s isn't in our records!" % exercise_id)
        #pull out data from the xml
        xmldata = parseString(request.raw_post_data)
        updated_solution_data  = xmldata.getElementsByTagName('solution')
        solutions = []

        for sd in updated_solution_data:

            if not sd.hasAttribute('id'):
                resp = rc.BAD_REQUEST
                resp.write("A solution was submitted without an id")
                return 

            id = int(sd.getAttribute('id'))
            try:
                solution = Solution.active_objects.get(id=id)
            except Solution.DoesNotExist:
                return not_here("The solution with id %s doesn't exisit yet! Try visiting the associated exercise to create it first" %id)


            result = get_xml_data('result', u'result', solution.result)
            explanation = get_xml_data('explanation', u'explanation', solution.explanation)
            ipad_state = get_xml_data('state', u'state', None)

            if sd.getElementsByTagName('finished')[0].firstChild:
                finished = True
            else:
                finished = False
                
            solution.result, solution.explanation, solution.modified_on = result, explanation, datetime.datetime.now()
            solution.finished, solution.data.ipad_state  = finished, ipad_state
            solutions.append(solution)

        [solution.save() for solution in solutions]
        return solutions
        
    
            
    
